from typing import Literal, TypeAlias
from typing import List, Literal
from pydantic import BaseModel, Field, model_validator
from .types import RoleLiteral, DetailLiteral


class TextContentPart(BaseModel):
    type: Literal["text"] = Field(description="The type of the content part.")
    text: str = Field(description="The text content.")


class ImageURL(BaseModel):
    url: str = Field(description="The URL of the image.")
    detail: DetailLiteral | None = Field(
        "auto", description="The detail level of the image."
    )


class ImageContentPart(BaseModel):
    type: Literal["image_url"] = Field(description="The type of the content part.")
    image_url: ImageURL = Field(description="The image URL and detail level.")


ContentPart: TypeAlias = TextContentPart | ImageContentPart


class FunctionCall(BaseModel):
    name: str = Field(description="The name of the function to call.")
    arguments: str = Field(
        description="The arguments to call the function with, as JSON."
    )


class ToolCall(BaseModel):
    id: str = Field(description="The ID of the tool call.")
    type: Literal["function"] = Field(
        description="The type of the tool. Only 'function' is supported."
    )
    function: FunctionCall = Field(description="The function that the model called.")


class Message(BaseModel):
    role: RoleLiteral = Field(description="The role of the message's author.")
    content: str | List[ContentPart] | None = Field(
        description=(
            "The contents of the message. Can be a string for text messages "
            "or an array of content parts for messages with images."
        )
    )
    name: str | None = Field(
        None,
        description=(
            "An optional name for the participant. Provides the model "
            "information to differentiate between participants of the same "
            "role."
        ),
        max_length=64,
    )
    tool_call_id: str | None = Field(
        None, description="The ID of the tool call. Required when role is 'tool'."
    )
    tool_calls: List[ToolCall] | None = Field(
        None,
        description=("The tool calls generated by the model, such as function calls."),
    )
    refusal: str | None = Field(
        None, description="The refusal message by the assistant."
    )

    @model_validator(mode="after")
    def validate_message(self) -> "Message":
        if self.role == "tool" and not self.tool_call_id:
            raise ValueError("tool_call_id required for 'tool' role")
        if self.role == "assistant" and not any(
            [self.content, self.tool_calls, self.function_call]
        ):
            raise ValueError(
                "Assistant messages require content, tool_calls, or function_call"
            )
        return self
